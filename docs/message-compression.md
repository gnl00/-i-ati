# 消息压缩功能文档

## 概述

消息压缩功能用于在长对话中自动压缩历史消息，减少发送给 LLM 的 token 数量，从而降低 API 成本并提高响应速度。

**核心原则**：
- 压缩仅影响发送给 LLM 的消息内容
- UI 始终显示完整的原始消息
- 压缩摘要持久化到数据库，避免重复调用 LLM

---

## 工作原理

### 1. 触发时机

在每次对话完成后（finalize 阶段），系统会自动检查是否需要压缩：

```
用户发送消息 → LLM 响应 → 保存消息 → 检查消息数量 → 触发压缩（如果超过阈值）
```

- **触发条件**：未压缩的消息数量 ≥ 触发阈值（默认 30 条）
- **执行方式**：异步执行，不阻塞用户操作

### 2. 压缩策略

系统采用"保留最近，压缩最老"的策略：

```
[消息1] [消息2] ... [消息20] [消息21] ... [消息30]
    ↓ 压缩最老的 10 条      ↓ 保留最近的 20 条
[压缩摘要]              [消息21] ... [消息30]
```

**配置参数**：
- **触发阈值**（triggerThreshold）：消息数超过此值时触发压缩，默认 30
- **保留最近数量**（keepRecentCount）：保留最近 N 条消息不压缩，默认 20
- **压缩数量**（compressCount）：每次压缩最老的 N 条消息，默认 10

### 3. 压缩过程

**步骤 1：分析策略**
- 获取当前会话的所有消息
- 获取已有的压缩摘要记录
- 过滤掉已被压缩的消息
- 计算需要压缩的消息范围

**步骤 2：生成摘要**
- 将选中的消息拼接成对话文本
- 构建压缩 prompt，要求 LLM 生成简洁摘要（500 字以内）
- 调用 LLM API 生成摘要
- 估算原始消息和摘要的 token 数量

**步骤 3：保存记录**
- 将压缩摘要保存到 `compressed_summaries` 表
- 记录被压缩的消息 ID 列表
- 记录压缩比率、时间戳等元信息
- 原始消息保持不变

### 4. 应用压缩

在构建发送给 LLM 的请求时（request 阶段），系统会自动应用压缩：

**原始消息列表**：
```
[消息1] [消息2] [消息3] ... [消息30] [新消息]
```

**应用压缩后**：
```
[压缩摘要: "之前讨论了..."] [消息21] ... [消息30] [新消息]
```

**处理逻辑**：
- 从数据库获取活跃的压缩摘要
- 创建被压缩消息的 ID 集合
- 遍历消息列表，跳过已被压缩的消息
- 在压缩范围的起始位置插入压缩摘要
- 压缩摘要使用 `user` 角色，内容格式为：`[Previous conversation summary (N messages compressed)]\n\n{摘要内容}`

---

## 数据流程

### 完整流程图

```
┌─────────────────────────────────────────────────────────────┐
│ 1. 用户发送消息                                              │
└─────────────────────┬───────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────────────────┐
│ 2. prepare 阶段：加载历史消息（完整原始消息）                │
└─────────────────────┬───────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────────────────┐
│ 3. request 阶段：应用压缩策略                                │
│    - 获取活跃的压缩摘要                                      │
│    - 用压缩摘要替换对应的原始消息                            │
│    - 保留最近 N 条原始消息                                   │
└─────────────────────┬───────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────────────────┐
│ 4. streaming 阶段：发送到 LLM（使用压缩后的消息）            │
└─────────────────────┬───────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────────────────┐
│ 5. finalize 阶段：保存消息后触发压缩检查                     │
│    - 检查消息总数是否超过阈值                                │
│    - 如果超过，异步调用 compressionService.compress()        │
│    - 不阻塞用户操作                                          │
└─────────────────────┬───────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────────────────┐
│ 6. 压缩服务执行                                              │
│    - 分析压缩策略（选择最老的 N 条消息）                     │
│    - 调用 LLM 生成摘要                                       │
│    - 保存压缩记录到 compressed_summaries 表                  │
│    - 原始消息保持不变                                        │
└─────────────────────────────────────────────────────────────┘
```

---

## 数据库设计

### compressed_summaries 表

| 字段 | 类型 | 说明 |
|------|------|------|
| id | INTEGER | 主键 |
| chat_id | INTEGER | 所属会话 ID |
| chat_uuid | TEXT | 所属会话 UUID |
| message_ids | TEXT | 被压缩的消息 ID 列表（JSON 数组） |
| start_message_id | INTEGER | 压缩范围起始消息 ID |
| end_message_id | INTEGER | 压缩范围结束消息 ID |
| summary | TEXT | 压缩摘要内容 |
| original_token_count | INTEGER | 原始消息 token 数量 |
| summary_token_count | INTEGER | 摘要 token 数量 |
| compression_ratio | REAL | 压缩比率 |
| compressed_at | INTEGER | 压缩时间戳 |
| compression_model | TEXT | 使用的压缩模型 |
| status | TEXT | 状态：active/superseded/invalid |

**索引**：
- `idx_compressed_summaries_chat_id`: 按 chat_id 查询
- `idx_compressed_summaries_status`: 按 status 过滤

---

## 核心组件

### 1. CompressionService（压缩服务）

**职责**：执行消息压缩的核心逻辑

**关键方法**：
- `analyzeCompressionStrategy()`: 分析哪些消息需要压缩
- `generateSummary()`: 调用 LLM 生成摘要
- `compress()`: 执行完整的压缩流程
- `estimateTokenCount()`: 估算 token 数量

**并发控制**：使用 `compressionInProgress` Map 避免同一会话的并发压缩

### 2. CompressionApplier（压缩应用器）

**职责**：将压缩摘要应用到消息列表

**关键方法**：
- `applyCompression()`: 用压缩摘要替换原始消息
- `buildCompressedMessage()`: 构建压缩消息对象

**处理逻辑**：
- 创建被压缩消息的 ID 集合
- 遍历消息列表，跳过已压缩的消息
- 在压缩范围起始位置插入摘要

### 3. CompressedSummaryRepository（数据访问层）

**职责**：管理压缩摘要的数据库操作

**关键方法**：
- `saveCompressedSummary()`: 保存压缩摘要
- `getActiveCompressedSummariesByChatId()`: 获取活跃的压缩摘要
- `updateCompressedSummaryStatus()`: 更新摘要状态
- `deleteCompressedSummary()`: 删除摘要

---

## 特性与优势

### 1. 渐进式压缩

支持多次压缩，每次基于上一次的摘要 + 新消息生成新摘要：

```
第一次压缩：[消息1-10] → [摘要1] + [消息11-30]
数据库：摘要1 (status: active)

第二次压缩：[摘要1] + [消息11-20] → [摘要2] + [消息21-40]
数据库：摘要1 (status: superseded), 摘要2 (status: active)

第三次压缩：[摘要2] + [消息21-30] → [摘要3] + [消息31-50]
数据库：摘要1 (superseded), 摘要2 (superseded), 摘要3 (active)
```

**优化策略**：
- 每个 chat 只保留一条活跃摘要（最新的）
- 新摘要基于旧摘要 + 新消息生成，避免内容冗余
- 旧摘要标记为 superseded，保留历史记录但不再使用
- 发送给 LLM 时只包含最新的活跃摘要

### 2. 透明性

- **UI 层面**：用户始终看到完整的原始消息，不会看到压缩摘要
- **数据层面**：原始消息永久保存在数据库中，不会被删除或修改
- **LLM 层面**：只有发送给 LLM 的请求使用压缩后的消息

### 3. 持久化

- 压缩摘要保存到数据库，避免重复调用 LLM
- 每次发送请求时直接从数据库读取摘要
- 节省 API 成本和响应时间

### 4. 异步执行

- 压缩在后台异步执行，不阻塞用户操作
- 用户可以立即继续对话，无需等待压缩完成
- 压缩失败不影响主流程

### 5. 智能策略

- 自动识别已压缩的消息，避免重复压缩
- 保留最近的消息以保持上下文连贯性
- 支持自定义压缩参数以适应不同场景

---

## 使用指南

### 配置压缩功能

1. 打开设置面板（Settings）
2. 切换到 "Tool" 标签页
3. 找到 "Message Compression" 设置项
4. 开启压缩开关
5. 配置压缩参数：
   - **Trigger Threshold**：建议设置为 30-50
   - **Keep Recent Count**：建议设置为 20-30
   - **Compress Count**：建议设置为 10-20
6. 点击 "Save" 保存配置

### 参数建议

**短对话场景**（10-30 条消息）：
- Trigger Threshold: 20
- Keep Recent Count: 15
- Compress Count: 5

**中等对话场景**（30-100 条消息）：
- Trigger Threshold: 30
- Keep Recent Count: 20
- Compress Count: 10

**长对话场景**（100+ 条消息）：
- Trigger Threshold: 50
- Keep Recent Count: 30
- Compress Count: 20

---

## 注意事项

### 1. 压缩时机

- 压缩在对话完成后自动触发，不需要手动操作
- 首次压缩会调用 LLM API，可能需要几秒钟
- 后续使用已保存的摘要，无需再次调用 API

### 2. Token 估算

- 系统使用简单算法估算 token 数量（中文 1.5 字符/token，英文 4 字符/token）
- 实际 token 数量可能略有差异
- 压缩比率通常在 0.1-0.3 之间（节省 70-90% token）

### 3. 上下文保持

- 保留最近的消息以保持对话连贯性
- 压缩摘要包含关键信息和决策
- LLM 仍能理解完整的对话上下文

### 4. 数据安全

- 原始消息永久保存，不会丢失
- 压缩摘要可以随时删除或重新生成
- 支持级联删除（删除会话时自动删除相关摘要）

---

## 技术实现要点

### 1. 异步处理

压缩在 finalize 阶段异步触发，使用 `.catch()` 捕获错误，确保不影响主流程。

### 2. 并发控制

使用 `compressionInProgress` Map 记录正在压缩的会话，避免同一会话的并发压缩。

### 3. 数据一致性

- 压缩摘要独立存储，不修改原始消息
- 使用 message_ids 字段记录被压缩的消息 ID
- 通过 status 字段管理摘要的生命周期

### 4. 性能优化

- 使用数据库索引加速查询
- 压缩摘要持久化，避免重复生成
- 异步执行不阻塞用户操作

---

## 总结

消息压缩功能通过智能的策略和持久化机制，在保证用户体验的前提下，显著降低了长对话的 token 消耗。核心设计原则是"对用户透明，对 LLM 有效"，确保用户始终看到完整的对话历史，同时 LLM 接收到的是经过优化的压缩内容。
